from django.db.models import F
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic
from django.http import Http404

from .models import Choice, Question


# def index(request):
#   # order_by() is used to sort query sets.
#   # [:5] is called slicing in Python. It means return the
#   # first five Question objects in this context.
#   latest_question_list = Question.objects.order_by("-pub_date")[:5]

#   # Dictionary data structure
#   context = {
#     "latest_question_list": latest_question_list,
#   }
#   return render(request, "polls/index.html", context)


class IndexView(generic.ListView):
  """
  By default, the DetailView generic view uses a
  template called <app name>/<model name>_detail.html.
  
  In our case, it would use the template "polls/question_detail.html".
  
  The template_name attribute is used to tell Django to
  use a specific template name instead of the autogenerated
  default template name.
  """
  template_name = "polls/index.html"

  context_object_name = "latest_question_list"

  # Each generic view needs to know what
  # model it will be acting upon.
  def get_queryset(self):
    """Return the last five published questions."""
    return Question.objects.order_by("-pub_date")[:5]


# def detail(request, question_id):
#   # Get a particular Question object based on its primary
#   # key (pk).

#   # http://127.0.0.1:8000/polls/specifics/1/

#   # Raises an Http404 if the object doesn’t exist.
#   question = get_object_or_404(Question, pk=question_id)

#   # Why is this here? Does this do the same as the previous line?
#   try:
#     question = Question.objects.get(pk=question_id)
#   except Question.DoesNotExist:
#     raise Http404("Question does not exist")
#   return render(request, "polls/detail.html", {"question": question})


class DetailView(generic.DetailView):
  # Each generic view needs to know what
  # model it will be acting upon.
  model = Question

  template_name = "polls/detail.html"


# def results(request, question_id):
#   response = "You're looking at the results of question %s."
#   return HttpResponse(response % question_id)

# def results(request, question_id):
#   # Raises an Http404 if the object doesn’t exist.
#   question = get_object_or_404(Question, pk=question_id)

#   return render(request, "polls/results.html", {"question": question})


class ResultsView(generic.DetailView):
  # Each generic view needs to know what
  # model it will be acting upon.
  model = Question

  template_name = "polls/results.html"


# def vote(request, question_id):
#   return HttpResponse("You're voting on question %s." % question_id)

# The vote() function is invoked when making
# a POST request to the following URL:
# http://127.0.0.1:8000/polls/1/vote/
def vote(request, question_id):
  # In this case, question_id will be equal to
  # 1 because it is included in the URL.
  print("\nEntered vote() function in the polls/views.py module.")

  # Attempt to get a Question object from the
  # database based on the "question_id" attribute.
  # Raise an Http404 exception if not found.
  question = get_object_or_404(Question, pk=question_id)

  # The Question object will be the one in the database
  # that has a primary key equal to the value of the
  # question_id parameter.
  print("\nquestion:", question)

  print("\nBefore form submission")

  print("\nrequest:", request)

  print("\nrequest.POST:", request.POST)

  print('\nrequest.POST["choice"]:', request.POST.get("choice"))

  # The program enters the try block only after the form
  # is submitted.
  try:
    # request.POST is a dictionary-like object that lets
    # you access submitted data by key name. In this case,
    # request.POST['choice'] returns the ID of the selected
    # choice, as a string. request.POST values are always strings.

    # choice_set will return the Choice objects that belong to
    # this particular Question object.

    # The get() method will grab the one whose primary key is
    # equal to the ID of the selected Choice object which is
    # the value returned by request.POST["choice"].

    # The primary key is identified using the "choice" key coming
    # from the request.POST dictionary.
    selected_choice = question.choice_set.get(pk=request.POST["choice"])

    print("\nAfter form submission")

    print("\nrequest: %s" %(request))

    print("\nrequest.POST:", request.POST)

    print('\nrequest.POST["choice"]:', request.POST.get("choice"))

    print("\nselected_choice:", selected_choice)

  # request.POST['choice'] will raise a KeyError
  # if "choice" wasn’t provided in POST data.
  # Assign something other than "choice" to <input> element's
  # "name" attribute in polls/templates/polls/detail.html.

  # The above code checks for KeyError and redisplays the
  # question form with an error message if choice isn’t given.
  except (KeyError, Choice.DoesNotExist):
    print("\nKeyError raised.", end="\n\n")

    # Re-display the question voting form.
    return render(
      request,
      "polls/detail.html",
      {
        "question": question,
        "error_message": "You didn't select a choice.",
      },
    )
  else:
    # An F() object represents the value of a model field.

    # It makes it possible to refer to model field values
    # and perform database operations.

    # "votes" is a data field for the Choice model class
    # in polls/models.py.

    # selected_choice.votes = F("votes") + 1 will ask the
    # database to add 1 to the value of "votes" at the time
    # the UPDATE is executed (when you call .save()), which
    # the database will do inside a transaction and will
    # ensure can't happen at the same time as another UPDATE.
    # This prevents racing conditions.
    selected_choice.votes = F("votes") + 1

    selected_choice.save()

    # Always return an HttpResponseRedirect after successfully dealing
    # with POST data. This prevents data from being posted twice if a
    # user hits the Back button.

    # The reverse() function in the HttpResponseRedirect constructor
    # helps avoid having to hardcode a URL in the view function.
    # It is given the name of the view that we want to pass control
    # to ("polls:results") and the variable portion of the URL
    # pattern that points to that view.

    # In this case, this reverse() call will return a string like:
    # "/polls/1/results/" where "1" is the value of question.id.

    print('reverse("polls:results", args=(question.id,)):', 
      reverse("polls:results", args=(question.id,)), end="\n\n")

    return HttpResponseRedirect(reverse("polls:results", args=(question.id,)))